---
title: "정렬 알고리즘(미완)"
categories: [codingTest]
date: 2023-05-28
tags: [codingTest, Algorithms]
---


# 정렬이란?

정렬 알고리즘은 데이터를 특정한 기준에 따라서 순서대로 나열하는 것이다. 프로그램이나 코딩 테스트에서 오름차순이나 내림차순으로 정렬하는 것은 빠질 수 없기에 정리하고자 한다. 특히 많이 사용되는 선택, 삽입, 퀵, 계수 정렬에 많이 사용하는 **결정 알고리즘**까지 정리할 것이다.

## 선택 정렬(Selection Sort)

선택 정렬은 정렬 알고리즘에서 가장 간단한 알고리즘으로 매번 **가장 작은 것을 선택하는 알고리즘**입니다.

선택 정렬의 동작 방식

1. 주어진 배열에서 최솟값을 찾습니다.
2. 최솟값과 현재 위치의 원소를 교환합니다.
3. 다음 위치로 이동하여 위의 과정을 반복합니다.

선택 정렬은 정렬 중간 과정에서도 배열의 상태를 유지하기 때문에 제자리(in-place)정렬 알고리즘이다.



> **제자리 정렬이란?**
> 
> 
> 추가적인 배열 공간을 사용하지 않고 주어진 배열 내에서 정렬을 수행하는 알고리즘으로 메모리 공간의 효율성을 높일 수 있고, 추가적인 공간 사용으로 인한 오버헤드를 없앨 수 있다.
> 

### 코드

```java
class Solution {
    public static void main(String args[]) {
        int[] arr = {7, 5, 9, 0, 3, 1, 4, 11, 21, 6};
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) minIndex = j;
            }
            int tmp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = tmp;
        }
        for (int i : arr) System.out.println(i);
    }
}
```

### 시간 복잡도

선택 정렬은 배열을 순회하면서 매번 최솟값을 찾아 정렬된 부분의 끝에 배치하는 방식으로 동작한다. 배열의 길이가 n인 경우, 첫 번째 반복에서 최솟값을 찾기 위해 n-1번의 비교를 하고 두 번쨰 반복에서는 n - 2번의 비교하는 식으로 반복된다. 

이렇게 비교 횟수가 배열의 길이에 비례하여 줄어들기 때문에 비교 연산 횟수는

$$
 (n-1)+(n-2)+(n-3)+...+1 = n(n-1)/2 
$$

이며 시간 복잡도는 O(n^2)이다.


## 삽입 정렬(Insertion Sort)

삽입 정렬은 입력 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분에서 값을 하나씩 선택하여 정렬된 부분에 삽입하는 알고리즘이다. 

선택 정렬은 현재 데이터 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 필요할 때만 위치를 바꾸기때문에 **데이터가 거의 정렬되어 있을 때 훨씬 효율적이다.**

삽입 정렬의 동작 방식

1. 첫 번째 데이터는 정렬되어 있다 생각하고 두 번째 원소부터 선택한다.
2. 선택한 데이터를 정렬된 부분의 적절한 위치에 삽입한다. 정렬된 데이터보다 작으면 왼쪽, 크면 오른쪽에 삽입한다.
3. 삽입한 이후 정렬된 부분의 부분의 크기를 증가시킨다. 
4. 위의 과정을 정렬되지 않은 부분에 대해 반복한다.

### 코드

```java
class Solution {
    public static void main(String args[]) {
        int[] arr = {7, 5, 9, 0, 3, 1, 4, 11, 21, 6};
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int tmp = arr[i], j;
            for (j = i - 1; j >= 0; j--) {
                if (arr[j] > tmp) {
                    arr[j + 1] = arr[j];
                } else break;
            }
            arr[j + 1] = tmp;
        }
        for (int i : arr) System.out.print(i + " ");
    }
}
```

### 시간 복잡도

삽입 정렬의 시간 복잡도는 최선일 때 O(n), 최악일 때는 O(n^2)이다. 최선일 때는 이미 정렬된 배열에서 알고리즘을 수행하는 경우로 삽입할 위치를 찾는 비교연산만 하기때문에 선형시간 O(n)만 소요된다. 

하지만 최악의 경우에는 삽입할 위치를 찾는 비교연산을 모든 원소에 대해 반복하기때문에 선택 정렬과 같은 O(n^2)이다.


