---
title: "[CS 지식] 개발 프로세스와 설계 원칙"
date: 2025-11-17 19:20:00 +0900
categories: [CS 지식, 아키텍처]
tags: [객체지향, SOLID, 아키텍처, 디자인 패턴]
---

# 객체지향프로그래밍(OOP)이란?

객체지향 프로그래밍(Object Oriented Programming)은 프로그램을 객체(Object)들의 모음으로 구성하는 프로그래밍 패러다임이다. 실세계의 사물이나 개념을 객체로 모델링하여, 데이터와 그 데이터를 처리하는 메서드를 하나로 묶어서 관리한다.

## 객체 지향 4가지 주요 특징

### 1. 캡슐화

데이터와 메서드를 하나로 묶고, 외부에서 직접 접근을 제한한다.

### 2. 상속

기존 클래스의 속성과 메서드를 새로운 클래스가 물려받아 재사용한다.

### 3. 다형성

같은 인터페이스나 메서드가 다양한 형태로 동작할 수 있다.(오버라이딩, 오버로딩을 통해 상황에 맞게 구현)

### 4. 추상화

복잡한 내부 구현을 숨기고 필요한 기능만 외부에 제공한다.(인터페이스나 추상 클래스)

### 절차지향과의 차이

- 절차지향은 프로그램이 정해진 순서대로 위에서 아래로 실행되는 흐름을 가진다. 데이터는 별도로 존재하고, 함수(기능)가 이 데이터를 가져와 처리하는 방식이다. 대표적으로 C언어가 있다.
- 객체지향은 설제 세상과 같이 여러 객체를 만들어 자신만의 데이터(속성)과 기능(메서드)을 하나로 묶어서(캡슐화) 가지고 있다. 프로그램은 객체들이 서로 메시지를 주고 받으며 상호작용하는 방식으로 동작한다. 대표적으로 Java, Python, C++이 있다.

## SOLID원칙이란?

SOLID 원칙은 객체지향 프로그래밍 설계를 더 쉽게 이해하고, 유지보수하기 쉽게 만들기 위한 다섯가지 핵심 원칙이다.

### SRP (단일 책임 원칙)

- 하나의 클래스는 하나의 책임만 가져야 한다.
- 클래스를 변경해야 할 이유는 오직 하나여야 한다는 뜻이다.

### OCP (개방-폐쇄 원칙)

- 소프트웨어 요소(클래스, 모듈, 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀있어야 한다.
- 새로운 기능을 추가할 때 기존의 코드를 수정하지 않고도 기능을 확장할 수 있어야 한다.

### LSP (리스코프 치환 원칙)

- 부모 클래스 타입의 객체를 자식 클래스 타입의 객체로 치환해도 프로그램이 오류 없이 정상적으로 작동해야 한다.
- 자식 클래스는 부모 클래스의 모든 규약(기능, 행동 방식)을 일관되게 따라야 한다는 뜻이다.

### ISP (인터페이스 분리 원칙)

- 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
- 하나의 큰 범용 인터페이스보다는 여러 개의 구체적이고 작은 인터페이스로 분리해야 한다는 뜻이다.

### DIP (의존성 역전 원칙)

- 상위 모듈은 하위 모듈에 직접 의존해서는 안 되며, 둘 모두 추상화에 의존해야 한다.
- 구체적인 것(구현 클래스)이 아닌 추상적인 것(인터페이스)에 의존해야 한다는 뜻이다.

저의 경험 중 클린 아키텍처의 도메인 계층에서 카프카를 사용해야 하는 경우가 있었는데, 카프카는 intstrature 계층으로 DIP에 위배하게 된다. 그래서 도메인 계층에 인터페이스를 만들어 추상화시켜 위배되지 않게 구현했다.

리스코프 치환 법칙으로는 쿠폰 할인 정책 구현에 “전략 패턴”을 구현했다. 픽스드와 퍼센트 할인이 있었는데 할인 정책이라는 인터페이스를 하나 만들고 픽스드, 퍼센트 할인을 구현했다. 스프링 빈이름을 구현체와 일치시켜 스프링에서 자동으로 구현체를 선택하게 구현했다.

## 도메인 주도 설계(DDD)

도메인 주도 설계(Domain Driven Design)는 복잡한 비즈니스 문제와 규칙을 이해하고 이를 소프트웨어 구조로 반영하는 방법론이다. DDD에서 도메인은 소프트웨어가 다루는 실제 문제 영역을 말하며, 예를 들어 쇼핑몰이라면 주문, 결제, 배송 각각이 하나의 독립적인 도메인이 된다. 

도메인마다 구체적이고 독립적인 경계를 정해두는 것은 각 기능의 변화와 독립성을 높여주는 동시에, 관련 코드와 데이터가 한데 모여 업무별로 **높은 응집도**를 갖게 만든다. 반면, 각 도메인이 불필요하게 서로 얽혀 있지 않도록 설계해두면, 모듈 간 의존성을 최소화해 **느슨한 결합**을 실현할 수 있다. 이러한 높은 응집도와 느슨한 결합의 설계는 나중에 마이크로서비스 아키텍처(MSA)로 구조를 바꿔야 할 때 큰 장점이 된다. 

## 테스트 주도 개발(TDD)

테스트 주도 개발(Test Driven Develpoment)이란 코드를 작성하기 전에 먼저 테스트부터 작성하는 소프트웨어 개발 방법론이다. 개발자는 구현하려는 기능에 대해 실패할 수밖에 없는 테스트 코드를 가장 먼저 만든다(Red 단계). 그다음, 이 테스트를 통과할 수 있을 정도로만 코드를 짜고(Green 단계), 필요한 경우 테스트와 코드를 모두 개선하며 다음 기능으로 넘어간다.(Refactor 단계)

기존의 개발 방식에서는 먼저 기획과 설계를 하고, 기능을 구현한 뒤, 마지막에 테스트 코드를 작성했다. 하지만 TDD는 기획 후 바로 테스트를 설계하고, 그 테스트를 통과할 수 있도록 구현하는 순서로 작업한다. 이런 접근법이 강조되는 이유는 초기 기획이 완벽하지 않더라도 반복적 테스트와 개선을 통해 요구사항 변경이나 버그를 빠르게 반영할 수 있다는 점에 있다

### 블랙박스, 화이트박스 테스트 차이

화이트박스 테스트는 소프트웨어의 내부 구조와 소스 코드를 모두 파악한 상태에서 코드의 분기, 조건문, 루프 등 세부 구현에 맞춰 테스트 케이스를 작성하는 방식이다. 이러한 테스트는 코드의 논리 흐름이나 세밀한 조건을 면밀히 검증할 수 있지만, 내부 구현에 상대적으로 강하게 결합되는 경향이 있다. 즉, 코드 구조나 메서드 흐름이 조금만 바뀌어도 테스트가 깨질 수 있고, 리팩토링 시 테스트 수정이 함께 필요해지는 경우가 많다.

반면 블랙박스 테스트는 프로그램의 내부 구조나 구현은 고려하지 않고, 입력과 출력 중심으로 기능이 의도한 대로 동작하는지를 검증한다. 이 방식은 요구사항과 외부 동작에 집중하기 때문에 내부 구조가 바뀌어도 큰 영향을 받지 않으며, 리팩토링에도 강한 특성을 가진다.

결국 화이트박스 테스트는 내부 코드와의 결합으로 인해 변화에 다소 취약한 반면, 블랙박스 테스트는 요구사항 수준에서 코드를 검증하기 때문에 구조 변경에도 잘 견딜 수 있다. 기능 요구사항이 유지되는 한 테스트가 쉽게 깨지지 않고, 리팩토링을 안정적으로 수행할 수 있기 때문에 주로 블랙박스 테스트를 선호한다.

## 디자인 패턴

디자인 패턴은 소프트웨어 설계 과정에서 반복적으로 등장하는 문제를 해결하기 위한 재사용 가능한 설계 기법이다. 패턴은 크게 **생성 패턴, 구조 패턴, 행위 패턴**의 세 가지로 분류된다.

### 생성 패턴

객체 생성 과정을 유연하게 만들고, 객체 생성 책임을 분리하여 코드 복잡도를 줄이는 패턴들이다.

- **Factory Method**: 객체 생성 로직을 서브클래스에 위임해 인스턴스를 생성하는 패턴
- **Singleton**: 애플리케이션 전체에서 하나의 인스턴스만 사용하도록 보장하는 패턴

### 구조 패턴

클래스와 객체를 조합해 더 큰 구조를 만들거나, 기존 구조를 유연하게 확장하는 데 사용된다.

- **Adapter**: 서로 다른 인터페이스를 가진 객체를 연결해 사용 가능하도록 해주는 패턴
- **Decorator**: 객체에 기능을 동적으로 추가할 수 있도록 하는 패턴

### 행위 패턴

객체 간의 상호작용, 책임 분배, 알고리즘 흐름 제어와 관련된 패턴이다.

- **Strategy**: 알고리즘을 인터페이스로 추상화하고 다양한 전략을 쉽게 교체 가능하게 하는 패턴
- **Observer**: 객체 상태 변화가 있을 때 의존 객체들에게 자동으로 알림을 보내는 패턴

## 아키텍처 설계의 3가지

### Layered Architecture (계층형 아키텍처)

가장 전통적이고 직관적인 아키텍처 패턴으로, 계층별로 역할을 명확히 분리한다. 상위 계층은 하위 계층에만 의존하는 단방향 의존성을 갖는다.(계층 건너뛰기 금지)

![layered_architecture.png](/assets/img/architecture/layered_architecture.png)

- **Presentation Layer**: UI, Controller (Request/Response 처리)
- **Business Layer**: Service (비즈니스 로직)
- **Persistence Layer**: Repository, DAO (데이터 접근)
- **Database Layer**: 실제 데이터베이스

#### 관련 아티클
[레이어드 아키텍처](https://martinfowler.com/bliki/PresentationDomainDataLayering.html)

### Clean Architecture

클린 아키텍처는 **비즈니스 로직을 중심에 두고 외부 기술(프레임워크, DB, UI)에 의존하지 않도록 설계하는 방식**이다. 의존성 방향이 항상 외부에서 내부로 향하는 것이 핵심이다.

![clean_architecture.png](/assets/img/architecture/clean_architecture.png)

- **Frameworks & Drivers**: 가장 바깥쪽 영역이며 변하기 쉬운 부분(Spring Framework, DB, UI)
- **Interface Adapters:** 외부와 내부를 연결하는 변환 계층(Controller, Presenter, Repository 인터페이스 구현)
- **Application: 애플리케이션 비즈니스 로직으로 시스템 유스케이스 구현(FindOrderUseCase, ..)**
- **Entities: 핵심 비즈니스 규칙과 도메인 모델(User, Order, 등 도메인 객체)**

#### 관련 아티클
[클린 아키텍처](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

### Hexagonal Architecture (Ports and Adapters)

헥사고날 아키텍처는 포트와 어댑터 아키텍처라고도 불리는 설계 패턴이다. **비즈니스 로직을 중심에 두고 외부 시스템과의 연결을 포트와 어댑터를 통해 분리하는 아키텍처이다.** 육각형 모양으로 보여져 헥사고날이라는 이름으로 불린다.

입력(사용자, API, 메시지 등)과 출력(DB,  외부 서비스, 파일, 메시지 큐, 등) 경계마다 **포트(Port)**라는 추상 인터페이스를 만들고, 필요한 동작은 **어댑터(Adapter)로 구현한다.**

![hexagonal_architecture.png](/assets/img/architecture/hexagonal_architecture.png)

- Application Core: 순수한 비즈니스 로직과 도메인 모델로 외부 기술에 대한 의존성이 전혀 없음
- Port: 애플리케이션과 외부를 연결하는 인터페이스로 두가지로 나뉨
    - Inbound Port(주도하는 포트): 애플리케이션 사용을 위한 인터페이스(OrderUseCase)
    - Outbound Port(주도되는 포트): 애플리케이션이 외부를 사용하기 위한 인터페이스(OrderRepository)
- Adapter: 포트를 구현하여 실제 기술과 연결. 포트와 같이 2가지로 구현
    - Primary/Driving Adapter (주도하는 어댑터): 애플리케이션을 호출(Controller, GraphQL, CLI)
    - Secondary/Driven Adapter (주도되는 어댑터): 애플리케이션에 의해 호출됨(JPA Repository)

#### 관련 아티클
[헥사고날아키텍처](https://alistair.cockburn.us/hexagonal-architecture)