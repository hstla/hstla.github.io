---
title: 네트워크 기초 정리
date: 2025-11-07 17:20:00 +0900
categories: [개발공부]
tags: [네트워크]
---

## 웹의 동작 방식

웹 통신의 큰 흐름: [https://www.google.com/](https://www.google.com/) 을 접속할 때 일어나는 일

![network.png](/assets/img/network/network.png)

1. 사용자가 브라우저 주소창에 `www.google.com`을 입력한다.
2. 브라우저는 DNS 서버로 UDP(53번 포트) 요청을 보내 도메인의 IP 주소를 조회한다.
3. IP 주소를 얻으면, 브라우저는 HTTP 또는 HTTPS 요청 메시지를 생성한다.
4. TCP 3-way handshake를 통해 서버와 연결을 설정한다. (HTTPS의 경우 추가로 TLS handshake를 수행한다.)
5. 연결이 완료되면, 브라우저는 HTTP 요청 메시지를 TCP 세그먼트에 담아 전송한다.
6. 서버는 요청을 처리한 뒤 HTTP 응답 메시지를 생성하여 TCP/IP 계층을 거쳐 클라이언트로 전송한다.
7. 브라우저는 받은 응답 데이터를 렌더링하여 화면에 웹 페이지를 표시한다.

## HTTP/HTTPS 프로토콜이란?

HTTP(Hyper Text Transfer Protocol) 클라이언트와 서버간 데이터를 주고 받기 위한 프로토콜이고 HTTPS는 HTTP security 를 추가한 프로토콜이다. 

#### HTTP 구성

HTTP 주요 구성은 헤더, 메서드, 바디, 버전 등이 있다.

HTTP 메서드로는 get, post, delete, put, patch가 있고 각 의미는 아래와 같다.

get: 데이터를 요청하는 메서드

post: 데이터를 생성하는 메서드

delete: 데이터를 삭제하라는 메서드

put: 데이터를 수정하라는 메서드

patch: 데이터의 일부를 수정하라는 메서드

메서드에 멱등성이라는 개념이 있는데 여기서 멱등성이란 동일한 요청을 반복해서 요청해도 같은 반환 값을 반환하는 메서드이다. get, delete, put 메서드가 멱등성 하다.

### SSL Handshake란?

클라이언트와 서버가 처음 만났을 때, 서로 신뢰를 확인하고 암호화 키(세션키)를 안전하게 교환하는 과정이다. 해당 과정에서는 대칭키와 공개키(비대칭키) 암/복호화가 사용되는데, 공개키는 안전하지만 느리고, 대칭키는 빠르지만 키 전달이 위험하므로, 처음에만 공개키 방식으로 세션키를 교환하고 이후에는 대칭키로 통신한다.

#### HTTPS 연결(SSL Handshake)

1. 클라이언트가 서버에 TCP 3way-handshake로 연결되면 clientHello 를 전달한다.
2. 서버는 인증서(공개키 포함)와 serverHello(암호화 방식, 세션 ID, 서버 랜덤 값 등)를 클라이언트에게 보낸다.
3. 클라이언트는 브라우저에 있는 CA 목록을 바탕으로 인증서를 검증한다.
4. 검증이 완료되면 대칭키가 될 임의의 세션키를 생성하고 인증서에 있던 공개키로 암호화하고 서버에 전달한다.
5. 서버는 전달 받은 세션키를 자신의 개인키로 복호화한다.
6. 이제 클라이언트와 서버밖에 모르는 세션키로 통신한다.

### HTTP 상태 코드 종류

100번대(정보): 요청을 받았으며 프로세스를 계속 진행

200번대(성공): 요청을 성공적으로 처리

- 200 OK: 가장 일반적인 성공 응답으로 get, put, patch 등의 요청이 성공적으로 처리되었을 떄 반환한다.
- 201 Created: 요청이 성공하여 새로운 리소스가 생성되었음을 의미한다.
- 202 Accepted: 요청이 접수되었으나 처리가 완료되지 않았음을 의미한다.(비동기/배치 처리에서 사용)
- 204 No Content: 요청이 성공했지만 본문이 없음을 의미하며, 주로 DELETE 요청 시 사용된다.

300번대(리다이렉션): 요청 완료를 위해 추가 작업 필요

- 301 Moved Permanently: 리소스가 영구적으로 이동됨.
- 302 Found: 임시적으로 다른 위치로 이동.
- 304 Not Modified: 캐시된 데이터 사용 가능

400번대(클라이언트 오류): 클라이언트의 요청이 잘못됨

- 400 Bad Request: 잘못된 요청
- 401 Unauthorized: 인증 필요
- 403 Forbidden: 권한 없음.
- 404 Not Found: 리소스를 찾을 수 없음

500번대(서버 오류): 서버가 요청을 처리하지 못함

- 500 Internal Server Error: 서버 내부 오류
- 502 Bad Gateway: 게이트웨이(프록시) 서버 오류
- 503 Service Unavailable: 서버 과부하 또는 점검 중

### Rest API란?

Rest(Representational State Transfer)는 HTTP 프로토콜을 기반으로 자원을 URI로 표현하고, HTTP 메서드로 자원에 대한 행위를 정의하는 아키텍처 스타일입니다.

REST의 핵심원칙은 6가지 입니다.

1. Stateless: 서버는 클라이언트의 상태를 저장하지 않는다.
2. Client-Server: 클라이언트와 서버가 서로 의존하지 않고 명확하게 분리되어야 한다.
3. Cacheable: 서버의 응답은 캐시 가능 여부를 명시해야 한다(`Cache-Control` 헤더).
4. Uniform Interface: 일관된 방식으로 자원을 요청하고 상호작용해야 된다.
5. Layered System: 클라이언트는 자신이 직접 통신하는 최종 서버를 알지 못해도 된다.
6. Code on Demand: 선택적 원칙으로, 서버가 클라이언트에게 실행 가능한 코드(ex: JavaScript)를 전송하면, 클라이언트가 그 코드를 실행하여 기능을 동적으로 확장할 수 있게 한다.

## TCP/IP & OSI 계층

### TCP/IP

TCP/IP는 데이터를 주고받기 위한 통신 규약(프로토콜)입니다. IP는 데이터를 어디로 보낼지 결정하고 데이터를 IP 패킷 단위로 나누어 전달합니다. 

TCP는 이런 패킷들이 손실 없이 순서대로 도착하도록 보장하며, 신뢰성 있는 통신을 제공합니다.

#### TCP 3 way handshake란?

TCP 3 way handshake는 클라이언트와 서버가 데이터를 주고받기 전에 서로 통신이 가능한지 확인하고 시퀀스 번호를 동기화하는 과정이다.

1. SYN(Synchronization): 클라이언트가 서버에 연결 요청을 보냅니다. 이때 SYN 플래그를 1로 설정하고, 자신의 초기 시퀀스 번호(ISN)를 함께 보낸다.
2. SYN + ACK (Acknowledgment): 서버가 요청을 받고, 연결을 수락할 준비가 되면 SYN과 ACK 플래그를 모두 1로 설정하여 클라이언트에 응답합니다.
3. ACK: 클라이언트가 서버의 응답을 받고, 서버의 시퀀스 번호(Y + 1)을 확인했다는 ACK 패킷을 보냅니다.

### UDP

UDP는 비연결형 전송 프로토콜로, TCP처럼 연결을 맺지 않고 데이터를 빠르게 전송합니다.

전송 속도가 빠르지만, 데이터 손실·순서 보장·재전송 기능이 없습니다.

### TCP와 UDP 차이

| 구분 | TCP | UDP |
| --- | --- | --- |
| 방식 | 연결형 | 비연결형 |
| 신뢰성 | 데이터 손실 및 순서 보장 | 손실, 순서 보장 X |
| 속도 | 상대적으로 느림 | 빠름 |
| 데이터 전송 단위 | 세그먼트 | 데이터그램 |

## osi 7계층과 TCP/IP 4계층

![osi7layer.jpeg](/assets/img/network/osi7layer.jpeg)

#### osi 7계층

데이터가 네트워크를 통해 전송될 때의 과정을 역할별로 구분하고 표준화한 국제표준화기구(ISO)의 네트워크 모델입니다.

7. 응용 계층(Application): 사용자와 직접 상호작용, 애플리케이션 서비스 제공(HTTP, FTP, SMTP)

6. 표현 계층 (Presentation) : 데이터 형식 변환, 암호화/복호화, 압축 (SSL/TLS, JPEG, MPEG)

5. 세션 계층 (Session): 통신 세션의 생성·유지·종료 관리 (NetBIOS, API 세션)

4.  전송 계층 (Transport): 신뢰성 있는 전송, 오류 제어, 순서 제어 (TCP, UDP)

3.  네트워크 계층 (Network): 주소 지정, 라우팅을 통한 경로 결정 (IP, ICMP, ARP)

2.  데이터 링크 계층 (Data Link): 물리 전송 오류 제어, MAC 주소 기반 통신 (Ethernet, Switch)

1. 물리 계층 (Physical): 전기적·물리적 신호로 데이터 전송 (케이블, 허브)

#### TCP/IP 4계층

인터넷 통신을 위해 데이터를 전송하는 과정을 4단계로 구분한 실제 구현 모델로, TCP/IP 프로토콜에 맞춰 OSI 7계층보다 단순화 시킨 계층입니다.

4. 응용 계층 (Application): 사용자 서비스 제공, 실제 애플리케이션 동작 (HTTP, FTP, DNS, SMTP)

3.  전송 계층 (Transport): 송신자와 수신자 간 신뢰성 있는 데이터 전송 (TCP, UDP)

2.  인터넷 계층 (Internet): IP 주소 기반 패킷 전달 및 라우팅 (IP, ICMP, ARP)

1.  네트워크 인터페이스 계층 (Network Interface): 물리적 전송 담당, 하드웨어 수준 통신 (Ethernet, Wi-Fi, MAC)

## 인증 구조 (Session / Token / JWT)

#### 세션(Session)

세션은 **서버가 사용자 상태를 유지하는 방식**이다.

사용자가 로그인을 하면 서버가 **세션 ID를 생성**하고, 이 ID를 **브라우저 쿠키에 저장**한다.

이후 요청마다 쿠키에 담긴 세션 ID를 보고 서버는 해당 사용자를 식별한다.

- **저장 위치:** 서버(메모리, Redis 등)
- **유효기간:** 서버에서 직접 관리
- **특징:**
    - 서버에서 상태를 유지하기 때문에 **Stateful**하다.
    - 서버가 여러 대일 경우 **세션 공유**가 필요해 **확장성이 낮다.**
    - 예를 들어, “사용자의 동시 접속 브라우저 수를 5개 이하로 제한” 같은 요구사항은 세션으로 처리할 수 있다.

#### 토큰(Token)

토큰은 **클라이언트가 인증 정보를 직접 가지고 있는 방식**이다.

로그인 시 서버는 **JWT(Json Web Token)** 을 발급하고, 클라이언트는 이후 요청마다 `Authorization` 헤더에 토큰을 담아 전송한다. 서버는 토큰의 **서명을 검증**하여 사용자를 식별한다.

- **저장 위치:** 클라이언트(로컬 스토리지 또는 쿠키)
- **유효기간:** 토큰 자체에 포함되어 있음
- **특징:**
    - 서버에서 상태를 저장하지 않기 때문에 **Stateless**하다.
    - **확장성이 높지만**, 토큰이 탈취될 경우 **보안 위험**이 존재한다.
    - 이를 보완하기 위해,
        - **Access Token:** 유효기간이 짧아 주기적으로 갱신됨
        - **Refresh Token:** 유효기간이 길어 Access Token을 재발급받는 용도로 사용됨

##### JWT란?

JSON Web Token은 사용자의 인증 정보를 JSON 형태로 인코딩한 토큰이다. 

Header, Payload, Signature 세 부분으로 구성되어 있다.

- Header: 토큰의 타입(JWT)과 서명 알고리즘
- Payload: 실제 담을 정보(예: userId, role, 발급시각, 만료시간 등)
- Signature: 위 두 부분을 비밀키로 서명한 값

#### 로컬 스토리지(Local Storage)

로컬 스토리지는 **브라우저에 데이터를 영구적으로 저장하는 클라이언트 측 저장소**이다.

쿠키와 달리 서버로 자동 전송되지 않고, 자바스크립트를 통해서만 읽고 쓸 수 있다.

- **저장 위치:** 브라우저 내부 (서버로 자동 전송되지 않음)
- **유효기간:** 명시적으로 삭제하지 않는 이상 **영구 저장**
- **특징:**
    - 용량이 **5MB 이상**으로 쿠키보다 훨씬 크다.
    - 서버 요청마다 자동 전송되지 않아 **네트워크 부하가 적고 빠르다.**

#### 쿠키(Cookie)

쿠키는 브라우저가 서버로부터 전달받은 작은 데이터 조각을 저장하는 방식이다.

서버는 로그인이나 사용자 설정 정보를 쿠키에 담아 브라우저에 전달하고, 이후 브라우저는 모든 요청마다 쿠키를 자동으로 함께 전송한다. 이 덕분에 서버는 사용자를 식별할 수 있다.

- **저장 위치:** 브라우저 내부 (자동으로 서버에 전송됨)
- **유효기간:** 서버나 클라이언트가 설정 가능 (만료 시 자동 삭제)
- **특징:**
    - 요청 시마다 서버에 자동으로 전송되어 **세션 관리나 인증에 자주 사용**된다.
    - 용량 제한이 약 **4KB** 정도로 작다.
    - 보안이 중요할 경우 `HttpOnly`, `Secure`, `SameSite` 속성으로 보호할 수 있다.

## 부록

### URL, URN, URI 차이

URI는 인터넷에서 자원을 식별하기 위한 문자열로 “이름표”라고 볼 수 있다.

URN과 URL은 URI의 하위 개념

URL은 자원의 “위치”를 알려주는 문자열로 어디에 있는지와 어떻게 접근하는지를 포함한다.

```java
https://www.google.com/search?q=hi
```

URN은 리소스의 이름을 나타내는 문자열로 어디에 있는지 상관없이 이름으로 식별할 수 있으면 된다.

```java
urn:isbn:9788966260959
```
