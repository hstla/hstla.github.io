---
title: "STM32 타이머와 PWM으로 LED 제어하기(NUCLEO‑F411RE)"
date: 2025-12-15 19:20:00 +0900
categories: [임베디드, STM32]
tags: [HAL, 타이머, PWM, LED]
# pin: true
math: true
mermaid: true
---

# LED 깜빡이기
Nucleo-F411RE 보드에서 HAL_Delay()를 활용한 블로킹 방식과 타이머·PWM 하드웨어에 맡기는 논블로킹 방식을 비교하면서 구현하려 한다.

## 프로젝트 설정

STM32CubeMX를 사용해 프로젝트를 생성한다. 먼저 Clock Configuration 탭에서 HCLK를 84MHz로 설정한다.   
여기서 HSE(External High‑Speed Clock)는 MCU 외부에서 공급받는 고속 클럭원으로, 사용하는 Nucleo 보드는 ST‑LINK 쪽에 연결된 8MHz 외부 오실레이터를 제공한다. HSE를 사용하면 내부 고속 클럭원인 HSI(Internal High‑Speed Clock)보다 주파수 정확도가 높다는 장점이 있다.

![clock_configuration](/assets/img/embedded/setting/clock_configuration.png)

pinout 탭에서는 PWM을 출력할 핀로 TIM2_CH1이 연결된 PA15를 선택했고, 이후에 외부 LED용으로 쓸 PC6, PC8, PC9를 일반 GPIO 출력으로 설정했다.

PWM의 한 주기를 1ms로 만들기 위해 타이머 설정 값을 공식에 따라 계산했다.

타이머 카운터 주파수는
$$
f_{\mathrm(cnt)} = \frac{f_{\mathrm(clk)}}{PSC + 1}
$$

> PSC(Prescaler) 분주기로 타이머가 세는 속도를 결정하는 레지스터다.  
ex) $f_{\mathrm(clk)} = 84MHz$ 일때, PSC = 83이면 $f_{\mathrm(cnt)} = \frac{84MHz}{83 + 1} = 1MHz$로 카운터가 1us마다 1씩 증가한다.
{: .prompt-info }

PWM 주파수
$$
f_{\mathrm(pwm)} = \frac{f_{\mathrm(cnt)}}{ARR + 1}
$$

> ARR(Autoreload Register)는 카운터 끝값/주기 레지스터로 카운터가 어디까지 세면 한 주기를 끝낼지 정하는 레지스터이다.  
ex) $f_{\mathrm(cnt)} = 1MHz$, ARR = 999이면 0 ~ 999까지 1000번 카운트 -> 1000us = 1ms가 한 주기가 된다.
{: .prompt-info }


위 둘의 공식을 합치면
$$
f_{\mathrm(pwm)} = \frac{f_{\mathrm(clk)}}{(PSC + 1)(ARR + 1)}
$$


한 주기가 1ms가 되려면 $f = \frac{1}{T}$ 에 의해 $f_{\mathrm(pwm)}$ = 1kHz가 되어야 한다. 이를 맞추기 위해 아래와 같이 값을 넣어놨다.
- Prescaler = 83  
- Counter Period = 999  
- Pulse = 500 (전체 1000카운트 중 절반만 HIGH로 두어 듀티 50%)

![clock_configuration](/assets/img/embedded/led/pin_out_setting_1ms.png)

1s가 아니라 1ms로 주기를 잡은 이유는, 나중에 더 짧은 시간이 필요해졌을 때를 대비하기 위해서다.  
PWM을 처음부터 1초 주기로 설정해 두면, 1ms가 필요할 때는 다른 타이머를 하나 더 쓰거나, 이미 쓰는 타이머의 설정 값을 코드에서 바꿔야 해서 관리가 복잡해진다.  
반대로 타이머를 1ms처럼 작은 단위로 고정해 두고, 소프트웨어에서 이 틱을 카운트해 1s 같은 큰 시간을 만들어 쓰면 구조가 단순하고 유지보수가 훨씬 쉬워진다.

만약 84HCLK일 때 1s도 설정하고 싶다면 아래처럼 설정해 주면 된다.

- Prescaler = 833
- Counter Period = 9999
- Pulse = 5000

![clock_configuration](/assets/img/embedded/led/pin_out_setting_1s.png)

## 코드 작성 및 실행
설정과 프로젝트 생성까지 완료했다. 이제 코드를 작성해서 LED를 깜빡여보자.
### HAL_Delay로 내부 LED 깜빡이기
`HAL_Delay()` 를 사용하면 LED를 쉽게 조절할 수 있다.  
내가 사용할 내부 LED는 PA5인데 프로젝트가 만들어지면서 STM32CubeMX에서 main.h에 정의를 해줬다.

```c
...
#define LD2_Pin GPIO_PIN_5
#define LD2_GPIO_Port GPIOA
...
```

이 정의를 바탕으로 코드를 작성하면 쉽게 LED를 제어할 수 있다.

```c
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();

  while (1)
  {
    HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
    HAL_Delay(500);                            
  }
}
```
### 실행 결과 확인
![led_blink_gif](/assets/img/embedded/led/led_blink1.gif){: .w-50 }

빌드 후 실행하면 LD2가 약 1초 주기로 깜빡이는 것을 확인할 수 있다.  
다만 `HAL_Delay()`는 블로킹 방식으로 동작하기 때문에 딜레이 동안 CPU가 다른 일을 거의 할 수 없고, 다른 작업이나 이벤트 처리가 지연될 수 있다는 단점이 있다. 이를 해결하기 위해, 프로젝트 생성 단계에서 설정해 둔 타이머/PWM을 이용해 LED를 제어하는 방식으로 바꿀 것이다.

### 설정한 TIM2 타이머로 내부 LED 제어
위에서 언급했듯이 `HAL_Delay()`는 지연 시간 동안 CPU가 다른 작업을 수행하지 못하는 블로킹(blocking) 구조라 한계가 있다. 이번에는 프로젝트 생성 때 설정한 TIM2 타이머 인터럽트를 사용해 LED를 제어한다.  
타이머 인터럽트 방식에서는 정해진 주기마다 인터럽트가 발생하고, LED 제어 로직은 인터럽트 핸들러에서 수행된다.

HAL_Delay 방식과의 차이
| 구분 |	HAL_Delay |	타이머 인터럽트 |
| :---- | :------- | ----------: |
|CPU 점유	| 높음 (블로킹)	| 낮음 (논블로킹) |
|확장성 |	낮음 |	높음 |
|주기 정확도 |	SysTick 의존 | 하드웨어 타이머 기반|
|멀티 태스크 |	어려움 |	유리 |
 
```c
volatile uint32_t tim2_ms_counter = 0;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM2)
  {
    tim2_ms_counter++;

    if (tim2_ms_counter >= 500)
    {
      tim2_ms_counter = 0;
      HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
    }
  }
}

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_TIM2_Init();
  HAL_TIM_Base_Start_IT(&htim2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

  for(;;) {}
}
```

#### 실행 결과
아래 영상은 TIM2 타이머 인터럽트를 사용해 내부 LED를 blink하는 모습이다.  
`HAL_Delay()` 사용하지 않고도 안정적인 주기 제어가 가능함을 확인했다.

<div style="text-align: center;">
  <video autoplay loop muted playsinline width="400">
    <source src="/assets/img/embedded/led/led_blink2.MOV" type="video/mp4">
  </video>
</div>
### 설정한 TIM2_CH1 타이머 출력 확인
프로젝트 생성 당시 PA15핀을 TIM2_CH1으로 설정했다. 해당 설정이 정상적으로 동작하는지 확인하기 위해 아래와 같은 코드를 작성하였다.  
PWM 주기가 길었다면 `HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);` 코드만 작성하면 되겠지만, 지금은 1ms 단위로 깜빡이기로 설정되었기때문에 사람이 깜빡이는걸 관측하기 힘들다. 

따라서 PWM 듀티 비율을 점진적으로 증가, 감소시키는 방식으로 LED가 점점 밝아지고 어두워지는지를 확인하여 TIM2_CM1출력이 정상적으로 동작하는지 검증했다.

```c
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_TIM2_Init();
  HAL_TIM_Base_Start_IT(&htim2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

  while (1)
    {
      // 0% → 100% 점점 밝아짐
      for (uint32_t duty = 0; duty <= htim2.Init.Period; duty += 50)
      {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, duty);
        HAL_Delay(10);
      }

      // 100% → 0% 점점 어두워짐
      for (int32_t duty = htim2.Init.Period; duty >= 0; duty -= 50)
      {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, duty);
        HAL_Delay(10);
      }
    }
}
```

#### 실행 결과
<div style="text-align: center;">
  <video autoplay loop muted playsinline width="400">
    <source src="/assets/img/embedded/led/led_blink3.MOV" type="video/mp4">
  </video>
</div>

위 영상을 통해 PWM 듀티 변경에 따라 LED 밝기가 점진적으로 변화하는 것을 확인했고 이를 통해 PA15핀에서 TIM2_CH1 출력이 정상적으로 동작했다는 걸 검증했다.  
다만 위 코드 역시 `HAL_Delay()` 를 사용한 폴링(polling) 방식으로 구현되어 있어 지연시간 동안 CPU가 다른 작업을 수행하지 못하는 한계가 있다.  

다음 글에서는 폴링 방식과 인터럽트 방식의 차이를 비교하고, 위 코드를 타이머 인터럽트 기반 구조로 개선해 볼 예정이다.